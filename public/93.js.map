{"version":3,"sources":["webpack:///./node_modules/lodash/debounce.js","webpack:///./node_modules/lodash/throttle.js","webpack:///./node_modules/lodash/now.js","webpack:///./src/client/components/Viewer/Extensions/Dynamic/Viewing.Extension.PointCloudMarkup/PointCloudMarkup/texture.png","webpack:///./src/client/components/Viewer/Extensions/Dynamic/Viewing.Extension.PointCloudMarkup/PointCloudMarkup/index.js","webpack:///./src/client/components/Viewer/Extensions/Dynamic/Viewing.Extension.PointCloudMarkup/PointCloudMarkup/PointCloudMarkup.js"],"names":["isObject","__webpack_require__","now","toNumber","FUNC_ERROR_TEXT","nativeMax","Math","max","nativeMin","min","module","exports","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","undefined","apply","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","setTimeout","timeWaiting","remainingWait","debounced","isInvoking","arguments","this","leadingEdge","cancel","clearTimeout","flush","debounce","root","Date","p","r","__webpack_exports__","_PointCloudMarkup__WEBPACK_IMPORTED_MODULE_0__","PointCloudMarkup","viewer","_this","length","_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default","_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default","_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default","call","onCameraChanged","bind","_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default","onVisibility","onExplode","dbIds","getAllDbIds","eventHandlers","event","Autodesk","Viewing","EXPLODE_CHANGE_EVENT","handler","CAMERA_CHANGE_EVENT","ISOLATE_EVENT","HIDE_EVENT","SHOW_EVENT","forEach","entry","addEventListener","geometry","THREE","Geometry","maxPoints","i","vertices","push","Vector3","shader","createShader","pointCloud","PointCloud","material","frustumCulled","impl","sceneAfter","add","markups","vertexShader","fragmentShader","tex","texture","defaultTex","shaderParams","side","DoubleSide","depthWrite","depthTest","opacity","attributes","pointSize","type","value","color","uniforms","ImageUtils","loadTexture","ShaderMaterial","stopwatch","Stopwatch","radius","setTexture","needsUpdate","update","dt","getElapsedMs","size","pixels","u","v","dist","sqrt","dataTexture","DataTexture","Uint8Array","from","RGBAFormat","UnsignedByteType","UVMapping","minFilter","LinearMipMapLinearFilter","magFilter","LinearFilter","generateTexture","_this2","markup","setMarkupColor","id","invalidate","runAnimation","_this3","Vector4","t","markupId","res","filter","override","getMarkupById","visible","__visible","index","occlusion","checkOcclusion","clr","fragId","mesh","getRenderProxy","model","pos","setFromMatrixPosition","matrixWorld","markupInfo","markupSize","Object","assign","initialFragPos","getFragmentPos","name","guid","vertex","x","point","y","z","verticesNeedUpdate","setMarkupSize","updateMarkup","emit","_this4","idx","data","occluded","_this5","state","clearMarkups","addMarkup","_this6","_this7","fragPos","setMarkupPosition","_this8","nodeIdArray","indexOf","dbId","__setMarkupVisibility","domElement","camera","pointerVector","pointerDir","ray","Raycaster","rect","getBoundingClientRect","left","width","top","height","isPerspective","set","unproject","position","sub","normalize","transformDirection","screenPoint","treshold","rayCaster","pointToRaycaster","canvas","intersectObjects","diff","clientPoint","worldToClient","offset","$","container","hitTest","rayIntersect","logOcclusionDist","console","log","occlusionDist","dbIdToIndex","getData","instanceTree","nodeAccess","keys","map","parseInt","_this9","remove","removeEventListener","off","EventsEmitter"],"mappings":"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","file":"93.js","sourcesContent":["var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","module.exports = __webpack_public_path__ + \"a91f7a1f684a8cae1c93a3e15fda6826.png\";","import PointCloudMarkup from './PointCloudMarkup'\n\nexport default PointCloudMarkup\n","/// ////////////////////////////////////////////////////////\n// PointCloudMarkup: high-perf markup 3D for Forge Viewer\n// by Philippe Leefsma, December 2017\n//\n/// ////////////////////////////////////////////////////////\nimport EventsEmitter from 'EventsEmitter'\nimport throttle from 'lodash/throttle'\nimport defaultTex from './texture.png'\nimport Stopwatch from 'Stopwatch'\n\nexport default class PointCloudMarkup extends EventsEmitter {\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  constructor (viewer, options = {}) {\n    super()\n\n    this.onCameraChanged = this.onCameraChanged.bind(this)\n    this.onVisibility = this.onVisibility.bind(this)\n    this.onExplode = this.onExplode.bind(this)\n\n    this.viewer = viewer\n\n    this.dbIds = this.getAllDbIds()\n\n    this.eventHandlers = [{\n      event: Autodesk.Viewing.EXPLODE_CHANGE_EVENT,\n      handler: this.onExplode\n    }, {\n      event: Autodesk.Viewing.CAMERA_CHANGE_EVENT,\n      handler: this.onCameraChanged\n    }, {\n      event: Autodesk.Viewing.ISOLATE_EVENT,\n      handler: this.onVisibility\n    }, {\n      event: Autodesk.Viewing.HIDE_EVENT,\n      handler: this.onVisibility\n    }, {\n      event: Autodesk.Viewing.SHOW_EVENT,\n      handler: this.onVisibility\n    }]\n\n    this.eventHandlers.forEach((entry) => {\n      this.viewer.addEventListener(\n        entry.event, entry.handler)\n    })\n\n    // Initialize geometry vertices\n    // and shader attribute colors\n    this.geometry = new THREE.Geometry()\n\n    const maxPoints = options.maxPoints || 10000\n\n    for (var i = 0; i < maxPoints; ++i) {\n      this.geometry.vertices.push(new THREE.Vector3())\n    }\n\n    this.shader = this.createShader(options)\n\n    // creates THREE.PointCloud\n    this.pointCloud = new THREE.PointCloud(\n      this.geometry, this.shader.material)\n\n    this.pointCloud.frustumCulled = false\n\n    // adds to the viewer scene\n    this.viewer.impl.sceneAfter.add(this.pointCloud)\n\n    // this.update = throttle(this.update, 10)\n\n    this.options = options\n\n    this.markups = []\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Generates custom shader using an updatable\n  // dynamic texture generated programmatically\n  //\n  /// //////////////////////////////////////////////////////\n  createShader (options) {\n    // Vertex Shader code\n    const vertexShader = options.vertexShader || `\n      attribute float pointSize;\n      attribute vec4 color;\n      varying vec4 vColor;\n      void main() {\n        vec4 vPosition = modelViewMatrix * vec4(position, 1.0);\n        gl_Position = projectionMatrix * vPosition;\n        gl_PointSize = pointSize;\n        vColor = color;\n      }\n    `\n\n    // Fragment Shader code\n    const fragmentShader = options.fragmentShader || `\n      uniform sampler2D texture;\n      varying vec4 vColor;\n      void main() {\n        vec4 tex = texture2D(texture, gl_PointCoord);\n        if (tex.a < 0.2) discard;\n        if (vColor.a == 0.0) {\n          gl_FragColor = vec4(tex.r, tex.g, tex.b, tex.a);\n        } else {\n          gl_FragColor = vColor;\n        }\n      }\n    `\n\n    const tex = options.texture || defaultTex\n\n    // Shader material parameters\n    const shaderParams = options.shaderParams || {\n      side: THREE.DoubleSide,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader,\n      vertexShader,\n      opacity: 0.5,\n      attributes: {\n        pointSize: {\n          type: 'f',\n          value: []\n        },\n        color: {\n          type: 'v4',\n          value: []\n        }\n      },\n      uniforms: {\n        texture: {\n          value: THREE.ImageUtils.loadTexture(tex),\n          type: 't'\n        }\n      }\n    }\n\n    // creates shader material\n    const material =\n      new THREE.ShaderMaterial(\n        shaderParams)\n\n    const generateTexture = (size, radius) => {\n      const pixels = []\n\n      for (let u = 0; u < size; ++u) {\n        for (let v = 0; v < size; ++v) {\n          const dist = Math.sqrt(\n            (u / size - 0.5) * (u / size - 0.5) +\n            (v / size - 0.5) * (v / size - 0.5))\n\n          if (dist < 0.1) {\n            pixels.push(0xff, 0x00, 0x00, 0xff)\n          } else if (dist < (radius - 0.05)) {\n            pixels.push(0xff, 0x00, 0x00, 0x00)\n          } else if (dist < radius) {\n            pixels.push(0xff, 0x00, 0x00, 0xff)\n          } else {\n            pixels.push(0x00, 0x00, 0x00, 0x00)\n          }\n        }\n      }\n\n      const dataTexture = new THREE.DataTexture(\n        Uint8Array.from(pixels),\n        size, size,\n        THREE.RGBAFormat,\n        THREE.UnsignedByteType,\n        THREE.UVMapping\n      )\n\n      dataTexture.minFilter = THREE.LinearMipMapLinearFilter\n      dataTexture.magFilter = THREE.LinearFilter // THREE.NearestFilter\n      dataTexture.needsUpdate = true\n\n      return dataTexture\n    }\n\n    const generateCanvasTexture = () => {\n      const canvas = document.createElement('canvas')\n      const ctx = canvas.getContext('2d')\n\n      ctx.font = '20pt Arial'\n      ctx.textAlign = 'center'\n      ctx.textBaseline = 'middle'\n      ctx.fillText(new Date().toLocaleString(),\n        canvas.width / 2, canvas.height / 2)\n\n      const canvasTexture = new THREE.Texture(canvas)\n\n      canvasTexture.needsUpdate = true\n      canvasTexture.flipX = false\n      canvasTexture.flipY = false\n\n      return canvasTexture\n    }\n\n    const stopwatch = new Stopwatch()\n\n    let radius = 0.0\n\n    return {\n      setTexture: (tex) => {\n        const { texture } = shaderParams.uniforms\n\n        texture.value = THREE.ImageUtils.loadTexture(tex)\n\n        texture.needsUpdate = true\n      },\n      update: () => {\n        const dt = stopwatch.getElapsedMs() * 0.001\n\n        radius += dt * 0.25\n\n        radius = radius > 0.5 ? 0.0 : radius\n\n        const { texture } = shaderParams.uniforms\n\n        // texture.value = generateCanvasTexture()\n        texture.value = generateTexture(96, radius)\n\n        texture.needsUpdate = true\n      },\n      material\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  startAnimation () {\n    this.markups.forEach((markup) => {\n      this.setMarkupColor(markup.id,\n        markup.color)\n    })\n\n    this.viewer.impl.invalidate(true)\n\n    this.runAnimation = true\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  stopAnimation () {\n    const texture = this.options.texture || defaultTex\n\n    this.shader.setTexture(texture)\n\n    this.markups.forEach((markup) => {\n      this.setMarkupColor(markup.id,\n        new THREE.Vector4(0, 0, 0, 0),\n        true)\n    })\n\n    this.viewer.impl.invalidate(true)\n\n    this.runAnimation = false\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  update (t) {\n    this.shader.update(t)\n\n    this.viewer.impl.invalidate(false, true, false)\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Returns markup from markupId\n  //\n  /// //////////////////////////////////////////////////////\n  getMarkupById (markupId) {\n    const res = this.markups.filter((markup) => {\n      return markup.id === markupId\n    })\n\n    return res.length ? res[0] : null\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Set markup size\n  //\n  /// //////////////////////////////////////////////////////\n  setMarkupSize (markupId, size, override) {\n    const { pointSize } = this.pointCloud.material.attributes\n\n    const markup = this.getMarkupById(markupId)\n\n    const visible = markup.visible && markup.__visible\n\n    if (override) {\n      pointSize.value[markup.index] = size\n    } else if (visible) {\n      if (markup.occlusion) {\n        if (!this.checkOcclusion(markup)) {\n          pointSize.value[markup.index] = size\n        }\n      } else {\n        pointSize.value[markup.index] = size\n      }\n    }\n\n    markup.size = !override ? size : markup.size\n\n    pointSize.needsUpdate = true\n\n    this.viewer.impl.invalidate(true)\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Set markup color\n  //\n  /// //////////////////////////////////////////////////////\n  setMarkupColor (markupId, clr, override) {\n    const { color } = this.pointCloud.material.attributes\n\n    const markup = this.getMarkupById(markupId)\n\n    color.value[markup.index] = clr\n\n    markup.color = !override ? clr : markup.color\n\n    color.needsUpdate = true\n\n    this.viewer.impl.invalidate(true)\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Adds new markup\n  //\n  /// //////////////////////////////////////////////////////\n  getFragmentPos (fragId) {\n    const mesh = this.viewer.impl.getRenderProxy(\n      this.viewer.model, fragId)\n\n    const pos = new THREE.Vector3()\n\n    pos.setFromMatrixPosition(mesh.matrixWorld)\n\n    return pos\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Adds new markup\n  //\n  /// //////////////////////////////////////////////////////\n  addMarkup (markupInfo) {\n    const size = markupInfo.size ||\n      this.options.markupSize ||\n      40\n\n    const index = this.markups.length\n\n    const markup = Object.assign({}, {\n      initialFragPos: this.getFragmentPos(markupInfo.fragId),\n      color: new THREE.Vector4(1, 0, 0, 1),\n      name: 'Markup ' + (index + 1),\n      id: this.guid('xxx-xxx-xxx'),\n      __visible: true,\n      occlusion: true,\n      visible: true,\n      size\n    }, markupInfo, {\n      index\n    })\n\n    const vertex = this.geometry.vertices[markup.index]\n\n    vertex.x = markup.point.x\n    vertex.y = markup.point.y\n    vertex.z = markup.point.z\n\n    this.geometry.verticesNeedUpdate = true\n\n    this.markups.push(markup)\n\n    this.setMarkupSize(\n      markup.id, markup.size)\n\n    this.updateMarkup(markup)\n\n    this.setMarkupColor(\n      markup.id,\n      this.runAnimation\n        ? markup.color\n        : new THREE.Vector4(0, 0, 0, 0),\n      !this.runAnimation)\n\n    this.emit('markup.created', markup)\n\n    return markup\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Removes markup\n  //\n  /// //////////////////////////////////////////////////////\n  removeMarkup (markupId) {\n    const { pointSize } = this.pointCloud.material.attributes\n\n    this.markups = this.markups.filter((markup) => {\n      return (markup.id !== markupId)\n    })\n\n    this.markups.forEach((markup, idx) => {\n      const vertex = this.geometry.vertices[idx]\n\n      pointSize.value[idx] = markup.size\n\n      vertex.x = markup.point.x\n      vertex.y = markup.point.y\n      vertex.z = markup.point.z\n\n      markup.index = idx\n\n      this.updateMarkup(markup)\n    })\n\n    for (let idx = this.markups.length;\n      idx < this.geometry.vertices.length; ++idx) {\n      pointSize.value[idx] = 0.0\n    }\n\n    this.geometry.verticesNeedUpdate = true\n\n    pointSize.needsUpdate = true\n\n    this.viewer.impl.invalidate(true)\n\n    this.emit('markup.deleted',\n      markupId)\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Clear all markups\n  //\n  /// //////////////////////////////////////////////////////\n  clearMarkups () {\n    const { pointSize } = this.pointCloud.material.attributes\n\n    const { length } = this.geometry.vertices\n\n    for (let idx = 0; idx < length; ++idx) {\n      pointSize.value[idx] = 0.0\n    }\n\n    pointSize.needsUpdate = true\n\n    this.viewer.impl.invalidate(true)\n\n    this.markups = []\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Set markup position\n  //\n  /// //////////////////////////////////////////////////////\n  setMarkupPosition (markupId, point) {\n    const markup = this.getMarkupById(markupId)\n\n    const vertex = this.geometry.vertices[markup.index]\n\n    vertex.x = point.x\n    vertex.y = point.y\n    vertex.z = point.z\n\n    this.geometry.verticesNeedUpdate = true\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Set markup data\n  //\n  /// //////////////////////////////////////////////////////\n  setMarkupData (markupId, data) {\n    const markup = this.getMarkupById(markupId)\n\n    Object.assign(markup, data)\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Set markup visibility: to hide markup, set size to 0\n  //\n  /// //////////////////////////////////////////////////////\n  setMarkupVisibility (markupId, visible) {\n    const markup = this.getMarkupById(markupId)\n\n    markup.visible = visible\n\n    this.updateMarkup(markup)\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Set markup visibility internal\n  //\n  /// //////////////////////////////////////////////////////\n  __setMarkupVisibility (markupId, __visible) {\n    const markup = this.getMarkupById(markupId)\n\n    markup.__visible = __visible\n\n    this.updateMarkup(markup)\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Set markup occlusion property\n  //\n  /// //////////////////////////////////////////////////////\n  setMarkupOcclusion (markupId, occlusion) {\n    const markup = this.getMarkupById(markupId)\n\n    markup.occlusion = occlusion\n\n    this.updateMarkup(markup)\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Update markup\n  //\n  /// //////////////////////////////////////////////////////\n  updateMarkup (markup) {\n    const visible = markup.visible && markup.__visible\n\n    if (visible) {\n      if (markup.occlusion) {\n        const occluded = this.checkOcclusion(markup)\n\n        this.setMarkupSize(markup.id,\n          occluded ? 0.0 : markup.size,\n          true)\n      } else {\n        this.setMarkupSize(markup.id,\n          markup.size,\n          true)\n      }\n    } else {\n      this.setMarkupSize(markup.id,\n        0.0, true)\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Get markups state\n  //\n  /// //////////////////////////////////////////////////////\n  getState () {\n    return {\n      markups: this.markups\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Restore state\n  //\n  /// //////////////////////////////////////////////////////\n  restoreState (state = {}) {\n    this.clearMarkups()\n\n    if (state.markups) {\n      state.markups.forEach((markup) => {\n        this.addMarkup(markup)\n      })\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Camera Changed event handler\n  //\n  /// //////////////////////////////////////////////////////\n  onCameraChanged (event) {\n    this.markups.forEach((markup) => {\n      const visible = markup.visible && markup.__visible\n\n      if (visible && markup.occlusion) {\n        const occluded = this.checkOcclusion(markup)\n\n        this.setMarkupSize(markup.id,\n          occluded ? 0.0 : markup.size,\n          true)\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Explode event handler\n  //\n  /// //////////////////////////////////////////////////////\n  onExplode (event) {\n    this.markups.forEach((markup) => {\n      const visible = markup.visible && markup.__visible\n\n      if (visible) {\n        const fragPos = this.getFragmentPos(markup.fragId)\n\n        const { point, initialFragPos } = markup\n\n        const pos = {\n          x: point.x + fragPos.x - initialFragPos.x,\n          y: point.y + fragPos.y - initialFragPos.y,\n          z: point.z + fragPos.z - initialFragPos.z\n        }\n\n        this.setMarkupPosition(markup.id, pos)\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Visibility Changed event handler\n  //\n  /// //////////////////////////////////////////////////////\n  onVisibility (event) {\n    this.markups.forEach((markup) => {\n      const dbIds = event.nodeIdArray\n\n      switch (event.type) {\n        case 'isolate':\n\n          // if this node is isolated or all nodes visible\n          if (dbIds.indexOf(markup.dbId) > -1 || !dbIds.length) {\n            this.__setMarkupVisibility(markup.id, true)\n\n            // if another node is isolated\n          } else if (dbIds.length) {\n            this.__setMarkupVisibility(markup.id, false)\n          }\n\n          break\n\n        case 'hide':\n\n          // this node is hidden\n          if (dbIds.indexOf(markup.dbId) > -1) {\n            this.__setMarkupVisibility(markup.id, false)\n          }\n\n          break\n\n        case 'show':\n\n          // this node is shown\n          if (dbIds.indexOf(markup.dbId) > -1) {\n            this.__setMarkupVisibility(markup.id, true)\n          }\n\n          break\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Creates Raycaster object from client point\n  //\n  /// //////////////////////////////////////////////////////\n  pointToRaycaster (domElement, camera, point) {\n    const pointerVector = new THREE.Vector3()\n    const pointerDir = new THREE.Vector3()\n    const ray = new THREE.Raycaster()\n\n    const rect = domElement.getBoundingClientRect()\n\n    const x = ((point.x - rect.left) / rect.width) * 2 - 1\n    const y = -((point.y - rect.top) / rect.height) * 2 + 1\n\n    if (camera.isPerspective) {\n      pointerVector.set(x, y, 0.5)\n\n      pointerVector.unproject(camera)\n\n      ray.set(camera.position,\n        pointerVector.sub(\n          camera.position).normalize())\n    } else {\n      pointerVector.set(x, y, -1)\n\n      pointerVector.unproject(camera)\n\n      pointerDir.set(0, 0, -1)\n\n      ray.set(pointerVector,\n        pointerDir.transformDirection(\n          camera.matrixWorld))\n    }\n\n    return ray\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Returns array of selected markups for given screenPoint\n  //\n  /// //////////////////////////////////////////////////////\n  getSelection (screenPoint, treshold = 0.9) {\n    const rayCaster = this.pointToRaycaster(\n      this.viewer.impl.canvas,\n      this.viewer.impl.camera, {\n        x: screenPoint.x,\n        y: screenPoint.y\n      })\n\n    const res = rayCaster.intersectObjects(\n      [this.pointCloud], true)\n\n    if (res.length) {\n      return this.markups.filter((markup) => {\n        const diff = {\n          x: res[0].point.x - markup.point.x,\n          y: res[0].point.y - markup.point.y,\n          z: res[0].point.z - markup.point.z\n        }\n\n        const dist = Math.sqrt(\n          diff.x * diff.x +\n          diff.y * diff.y +\n          diff.z * diff.z)\n\n        return dist < treshold\n      })\n    }\n\n    return []\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Occlusion check: return true if markup\n  // is being occluded\n  //\n  /// //////////////////////////////////////////////////////\n  checkOcclusion (markup) {\n    const clientPoint = this.viewer.worldToClient(\n      markup.point)\n\n    const offset = $(this.viewer.container).offset()\n\n    const rayCaster = this.pointToRaycaster(\n      this.viewer.impl.canvas,\n      this.viewer.impl.camera, {\n        x: clientPoint.x + offset.left,\n        y: clientPoint.y + offset.top\n      })\n\n    const hitTest = this.viewer.model.rayIntersect(\n      rayCaster, true, this.dbIds)\n\n    if (hitTest) {\n      if (hitTest.fragId === markup.fragId) {\n        const offset = {\n          x: hitTest.point.x - markup.point.x,\n          y: hitTest.point.y - markup.point.y,\n          z: hitTest.point.z - markup.point.z\n        }\n\n        const dist = Math.sqrt(\n          offset.x * offset.x +\n          offset.y * offset.y +\n          offset.z * offset.z)\n\n        if (this.options.logOcclusionDist) {\n          console.log(dist)\n        }\n\n        if (dist < this.options.occlusionDist) {\n          return false\n        }\n      }\n\n      return true\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Get list of all dbIds in the model\n  //\n  /// //////////////////////////////////////////////////////\n  getAllDbIds () {\n    const { instanceTree } = this.viewer.model.getData()\n\n    const { dbIdToIndex } = instanceTree.nodeAccess\n\n    return Object.keys(dbIdToIndex).map((dbId) => {\n      return parseInt(dbId)\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Removes everything\n  //\n  /// //////////////////////////////////////////////////////\n  destroy () {\n    this.viewer.impl.sceneAfter.remove(this.pointCloud)\n\n    this.eventHandlers.forEach((entry) => {\n      this.viewer.removeEventListener(\n        entry.event, entry.handler)\n    })\n\n    this.runAnimation = false\n\n    this.markups = []\n\n    this.off()\n  }\n}\n"],"sourceRoot":""}