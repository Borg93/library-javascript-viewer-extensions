{"version":3,"sources":["webpack:///./src/client/components/Viewer/Viewer.Toolkit/index.js","webpack:///./src/client/components/Viewer/Viewer.Toolkit/Viewer.Toolkit.js"],"names":["_Viewer_Toolkit__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","ViewerToolkit","Toolkit","format","arguments","length","undefined","d","Date","getTime","guid","replace","c","r","Math","random","floor","toString","urn","Promise","resolve","reject","paramUrn","startsWith","Autodesk","Viewing","Document","load","doc","error","roles","rootItem","getRootItem","items","roleArray","Array","isArray","forEach","role","concat","_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default","getSubItemsWithProperties","type","id","className","tooltip","handler","button","UI","Button","icon","style","fontSize","setToolTip","onClick","viewer","ctrlGroupName","viewerToolbar","getToolbar","ctrlGroup","ControlGroup","addControl","model","dbIds","instanceTree","getData","getFragmentMap","getRootId","dbIdArray","leafIds","dbId","getLeafNodeIdsRec","childCount","enumNodeChildren","childId","push","ex","_ref","_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default","_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default","a","mark","_callee2","i","_ret","wrap","_context2","prev","next","delegateYield","_callee","it","fragIds","leafFragIds","_context","getLeafNodes","t0","sent","enumNodeFragments","fragId","getLeafFragIds","abrupt","v","stop","_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default","t1","_x","_x2","apply","this","leafId","fragments","dbId2fragId","_ref2","_callee3","fragList","fragbBox","nodebBox","_context3","getFragIds","getFragmentList","THREE","Box3","getWorldBounds","union","_x3","_x4","requestedProps","dbIdInt","parseInt","isNaN","propTasks","map","displayName","getProperty","all","then","properties","getProperties","result","defaultValue","prop","displayValue","Error","_ref3","_callee4","propertyTasks","propertyResults","_context4","activeModel","propertyResult","indexOf","sort","_x5","_x6","propFilter","_this","_ref4","_callee5","propRes","filteredRes","propFilterArray","_context5","filter","res","getBulkProperties","console","log","_x7","_x8","components","defaultProp","_ref5","_callee6","results","componentsMap","_context6","getBulkPropertiesAsync","Object","assign","value","split","_x9","_x10","root","taskFunc","tasks","runTaskOnDataTreeRec","node","parent","children","childNode","task","min","max","material","overlayId","geometry","Geometry","vertices","Vector3","x","y","z","lines","Line","LinePieces","impl","addOverlay","invalidate","setMaterial","createNodeFunc","_buildModelTreeRec","name","getNodeName","rootId","rootNode","taskResults","executeTaskOnModelTreeRec","hide","targetIds","visibilityManager","setNodeOff","show","isolate","targetLeafIds","leafTasks","resolveLeaf","_context8","axis","angle","center","quaternion","Quaternion","setFromAxisAngle","fragProxy","getFragmentProxy","getAnimTransform","position","applyQuaternion","add","multiplyQuaternions","updateAnimTransform","state","immediate","onStateRestored","removeEventListener","VIEWER_STATE_RESTORED_EVENT","pivot","viewport","pivotPoint","setTimeout","navigation","setPivotPoint","addEventListener","restoreState","parentId","faceFilter","matrixWorld","meshGeometry","renderProxy","getRenderProxy","attributes","positions","vb","array","indices","index","ib","stride","vbstride","offsets","count","start","oi","ol","il","b","vA","vB","vC","fromArray","faceIdx","face","Face3","faces","applyMatrix","buildComponentGeometry","computeFaceNormals","computeVertexNormals","mesh","Mesh","scale","excludedFragIds","svf","mc","getVisibleBounds","pt","nodeAccess","nodeBoxes","scaledExplodeDepth","maxDepth","explodeDepth","currentSegmentFraction","tmpBox","Float32Array","explodeRec","nodeId","depth","cx","cy","cz","ox","oy","oz","oscale","getNodeBox","mycx","mycy","mycz","boxes","nbFrags","getCount","box_offset","getUserAgent","navigator","userAgent","isAndroid","match","isBlackBerry","isIOS","isOpera","isWindows","isWindowsDesktop","isWindowsMobile","isAny"],"mappings":"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","file":"1.js","sourcesContent":["import ViewerToolkit from './Viewer.Toolkit'\n\nexport default ViewerToolkit\n","\nexport default class Toolkit {\n  /// ////////////////////////////////////////////////////////\n  //\n  //\n  /// ////////////////////////////////////////////////////////\n  static guid (format = 'xxxxxxxxxxxx') {\n    var d = new Date().getTime()\n\n    var guid = format.replace(\n      /[xy]/g,\n      function (c) {\n        var r = (d + Math.random() * 16) % 16 | 0\n        d = Math.floor(d / 16)\n        return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16)\n      })\n\n    return guid\n  }\n\n  /// //////////////////////////////////////////\n  // mobile detection\n  //\n  /// //////////////////////////////////////////\n  static get mobile () {\n    return {\n\n      getUserAgent: function () {\n        return navigator.userAgent\n      },\n      isAndroid: function () {\n        return this.getUserAgent().match(/Android/i)\n      },\n      isBlackBerry: function () {\n        return this.getUserAgent().match(/BlackBerry/i)\n      },\n      isIOS: function () {\n        return this.getUserAgent().match(/iPhone|iPad|iPod/i)\n      },\n      isOpera: function () {\n        return this.getUserAgent().match(/Opera Mini/i)\n      },\n      isWindows: function () {\n        return this.isWindowsDesktop() || this.isWindowsMobile()\n      },\n      isWindowsMobile: function () {\n        return this.getUserAgent().match(/IEMobile/i)\n      },\n      isWindowsDesktop: function () {\n        return this.getUserAgent().match(/WPDesktop/i)\n      },\n      isAny: function () {\n        return this.isAndroid() ||\n          this.isBlackBerry() ||\n          this.isIOS() ||\n          this.isWindowsMobile()\n      }\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Load a document from URN\n  //\n  /// //////////////////////////////////////////////////////\n  static loadDocument (urn) {\n    return new Promise((resolve, reject) => {\n      const paramUrn = !urn.startsWith('urn:')\n        ? 'urn:' + urn\n        : urn\n\n      Autodesk.Viewing.Document.load(paramUrn, (doc) => {\n        resolve(doc)\n      }, (error) => {\n        reject(error)\n      })\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Return viewables\n  //\n  /// //////////////////////////////////////////////////////\n  static getViewableItems (doc, roles = ['3d', '2d']) {\n    const rootItem = doc.getRootItem()\n\n    let items = []\n\n    const roleArray = roles\n      ? (Array.isArray(roles) ? roles : [roles])\n      : []\n\n    roleArray.forEach((role) => {\n      items = [...items,\n        ...Autodesk.Viewing.Document.getSubItemsWithProperties(\n          rootItem, { type: 'geometry', role }, true)]\n    })\n\n    return items\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Toolbar button\n  //\n  /// //////////////////////////////////////////////////////\n  static createButton (id, className, tooltip, handler) {\n    var button = new Autodesk.Viewing.UI.Button(id)\n\n    button.icon.style.fontSize = '24px'\n\n    button.icon.className = className\n\n    button.setToolTip(tooltip)\n\n    button.onClick = handler\n\n    return button\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Control group\n  //\n  /// //////////////////////////////////////////////////////\n  static createControlGroup (viewer, ctrlGroupName) {\n    var viewerToolbar = viewer.getToolbar(true)\n\n    if (viewerToolbar) {\n      var ctrlGroup = new Autodesk.Viewing.UI.ControlGroup(\n        ctrlGroupName)\n\n      viewerToolbar.addControl(ctrlGroup)\n\n      return ctrlGroup\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  static getLeafNodes (model, dbIds) {\n    return new Promise((resolve, reject) => {\n      try {\n        const instanceTree =\n          model.getData().instanceTree ||\n          model.getFragmentMap()\n\n        dbIds = dbIds || instanceTree.getRootId()\n\n        const dbIdArray = Array.isArray(dbIds)\n          ? dbIds\n          : [dbIds]\n\n        const leafIds = []\n\n        const getLeafNodeIdsRec = (id) => {\n          let childCount = 0\n\n          instanceTree.enumNodeChildren(id, (childId) => {\n            getLeafNodeIdsRec(childId)\n            ++childCount\n          })\n\n          if (childCount === 0) {\n            leafIds.push(id)\n          }\n        }\n\n        dbIdArray.forEach((dbId) => {\n          getLeafNodeIdsRec(dbId)\n        })\n\n        return resolve(leafIds)\n      } catch (ex) {\n        return reject(ex)\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // get node fragIds\n  //\n  /// //////////////////////////////////////////////////////\n  static getFragIds (model, dbIds) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const it = model.getData().instanceTree\n\n        dbIds = dbIds || it.getRootId()\n\n        const dbIdArray = Array.isArray(dbIds)\n          ? dbIds : [dbIds]\n\n        const leafIds = it\n          ? await Toolkit.getLeafNodes(model, dbIdArray)\n          : dbIdArray\n\n        let fragIds = []\n\n        for (var i = 0; i < leafIds.length; ++i) {\n          if (it) {\n            it.enumNodeFragments(\n              leafIds[i], (fragId) => {\n                fragIds.push(fragId)\n              })\n          } else {\n            const leafFragIds =\n              Toolkit.getLeafFragIds(\n                model, leafIds[i])\n\n            fragIds = [\n              ...fragIds,\n              ...leafFragIds\n            ]\n          }\n        }\n\n        return resolve(fragIds)\n      } catch (ex) {\n        return reject(ex)\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // get leaf node fragIds\n  //\n  /// //////////////////////////////////////////////////////\n  static getLeafFragIds (model, leafId) {\n    if (model.getData().instanceTree) {\n      const it = model.getData().instanceTree\n\n      const fragIds = []\n\n      it.enumNodeFragments(\n        leafId, (fragId) => {\n          fragIds.push(fragId)\n        })\n\n      return fragIds\n    } else {\n      const fragments = model.getData().fragments\n\n      const fragIds = fragments.dbId2fragId[leafId]\n\n      return !Array.isArray(fragIds)\n        ? [fragIds]\n        : fragIds\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Node bounding box\n  //\n  /// //////////////////////////////////////////////////////\n  static getWorldBoundingBox (model, dbId) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        var fragIds =\n          await Toolkit.getFragIds(\n            model, dbId)\n\n        if (!fragIds.length) {\n          return reject('No geometry, invalid dbId?')\n        }\n\n        var fragList = model.getFragmentList()\n\n        var fragbBox = new THREE.Box3()\n        var nodebBox = new THREE.Box3()\n\n        fragIds.forEach(function (fragId) {\n          fragList.getWorldBounds(fragId, fragbBox)\n          nodebBox.union(fragbBox)\n        })\n\n        return resolve(nodebBox)\n      } catch (ex) {\n        return reject(ex)\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Gets properties from component\n  //\n  /// //////////////////////////////////////////////////////\n  static getProperties (model, dbId, requestedProps = null) {\n    return new Promise((resolve, reject) => {\n      try {\n        const dbIdInt = parseInt(dbId)\n\n        if (isNaN(dbIdInt)) {\n          return reject(dbId + ' is not a valid integer')\n        }\n\n        if (requestedProps) {\n          const propTasks = requestedProps.map((displayName) => {\n            return Toolkit.getProperty(\n              model, dbIdInt, displayName, 'Not Available')\n          })\n\n          Promise.all(propTasks).then((properties) => {\n            resolve(properties)\n          })\n        } else {\n          model.getProperties(dbIdInt, (result) => {\n            if (result.properties) {\n              return resolve(\n                result.properties)\n            }\n\n            return reject('No Properties')\n          })\n        }\n      } catch (ex) {\n        return reject(ex)\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  static getProperty (model, dbId, displayName, defaultValue) {\n    return new Promise((resolve, reject) => {\n      try {\n        model.getProperties(dbId, (result) => {\n          if (result.properties) {\n            result.properties.forEach((prop) => {\n              prop.dbId = dbId\n\n              if (typeof displayName === 'function') {\n                if (displayName(prop.displayName)) {\n                  resolve(prop)\n                }\n              } else if (displayName === prop.displayName) {\n                resolve(prop)\n              }\n            })\n\n            if (defaultValue) {\n              return resolve({\n                displayValue: defaultValue,\n                displayName,\n                dbId\n              })\n            }\n\n            reject(new Error('Not Found'))\n          } else {\n            reject(new Error('Error getting properties'))\n          }\n        })\n      } catch (ex) {\n        return reject(ex)\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Gets all existing properties from component  dbIds\n  //\n  /// //////////////////////////////////////////////////////\n  static getPropertyList (viewer, dbIds, model = null) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        model = model || viewer.activeModel || viewer.model\n\n        var propertyTasks = dbIds.map((dbId) => {\n          return Toolkit.getProperties(model, dbId)\n        })\n\n        var propertyResults = await Promise.all(\n          propertyTasks)\n\n        var properties = []\n\n        propertyResults.forEach((propertyResult) => {\n          propertyResult.forEach((prop) => {\n            if (properties.indexOf(prop.displayName) < 0) {\n              properties.push(prop.displayName)\n            }\n          })\n        })\n\n        return resolve(properties.sort())\n      } catch (ex) {\n        return reject(ex)\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  static getBulkPropertiesAsync (model, dbIds, propFilter) {\n    return new Promise(async (resolve, reject) => {\n      if (typeof propFilter === 'function') {\n        const propTasks = dbIds.map((dbId) => {\n          return this.getProperty(\n            model, dbId, propFilter, 'Not Found')\n        })\n\n        const propRes = await Promise.all(propTasks)\n\n        const filteredRes = propRes.filter((res) => {\n          return res.displayValue !== 'Not Found'\n        })\n\n        resolve(filteredRes.map((res) => {\n          return {\n            properties: [res],\n            dbId: res.dbId\n          }\n        }))\n      } else {\n        const propFilterArray = Array.isArray(propFilter)\n          ? propFilter : [propFilter]\n\n        model.getBulkProperties(dbIds, propFilterArray, (result) => {\n          resolve(result)\n        }, (error) => {\n          console.log(error)\n          reject(error)\n        })\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Maps components by property\n  //\n  /// //////////////////////////////////////////////////////\n  static mapComponentsByProp (model, propFilter, components, defaultProp) {\n    return new Promise(async (resolve, reject) => {\n      try {\n      //  components = components || await Toolkit.getLeafNodes(model)\n        const results = await Toolkit.getBulkPropertiesAsync(\n          model, components, propFilter)\n\n        const propertyResults = results.map((result) => {\n          const prop = result.properties[0]\n\n          return Object.assign({}, prop, {\n            dbId: result.dbId\n          })\n        })\n\n        var componentsMap = {}\n\n        propertyResults.forEach((result) => {\n          var value = result.displayValue\n\n          if (typeof value === 'string') {\n            value = value.split(':')[0]\n          }\n\n          if (!componentsMap[value]) {\n            componentsMap[value] = []\n          }\n\n          componentsMap[value].push(result.dbId)\n        })\n\n        return resolve(componentsMap)\n      } catch (ex) {\n        return reject(ex)\n      }\n    })\n  }\n\n  /// //////////////////////////////////////////////////////////\n  // Runs recursively the argument task on each node\n  // of the data tree\n  //\n  /// //////////////////////////////////////////////////////////\n  static runTaskOnDataTree (root, taskFunc) {\n    var tasks = []\n\n    var runTaskOnDataTreeRec = (node, parent = null) => {\n      if (node.children) {\n        node.children.forEach((childNode) => {\n          runTaskOnDataTreeRec(childNode, node)\n        })\n      }\n\n      var task = taskFunc(node, parent)\n\n      tasks.push(task)\n    }\n\n    runTaskOnDataTreeRec(root)\n\n    return Promise.all(tasks)\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  static drawBox (viewer, min, max, material, overlayId) {\n    const geometry = new THREE.Geometry()\n\n    geometry.vertices.push(new THREE.Vector3(min.x, min.y, min.z))\n    geometry.vertices.push(new THREE.Vector3(max.x, min.y, min.z))\n\n    geometry.vertices.push(new THREE.Vector3(max.x, min.y, min.z))\n    geometry.vertices.push(new THREE.Vector3(max.x, min.y, max.z))\n\n    geometry.vertices.push(new THREE.Vector3(max.x, min.y, max.z))\n    geometry.vertices.push(new THREE.Vector3(min.x, min.y, max.z))\n\n    geometry.vertices.push(new THREE.Vector3(min.x, min.y, max.z))\n    geometry.vertices.push(new THREE.Vector3(min.x, min.y, min.z))\n\n    geometry.vertices.push(new THREE.Vector3(min.x, max.y, max.z))\n    geometry.vertices.push(new THREE.Vector3(max.x, max.y, max.z))\n\n    geometry.vertices.push(new THREE.Vector3(max.x, max.y, max.z))\n    geometry.vertices.push(new THREE.Vector3(max.x, max.y, min.z))\n\n    geometry.vertices.push(new THREE.Vector3(max.x, max.y, min.z))\n    geometry.vertices.push(new THREE.Vector3(min.x, max.y, min.z))\n\n    geometry.vertices.push(new THREE.Vector3(min.x, max.y, min.z))\n    geometry.vertices.push(new THREE.Vector3(min.x, max.y, max.z))\n\n    geometry.vertices.push(new THREE.Vector3(min.x, min.y, min.z))\n    geometry.vertices.push(new THREE.Vector3(min.x, max.y, min.z))\n\n    geometry.vertices.push(new THREE.Vector3(max.x, min.y, min.z))\n    geometry.vertices.push(new THREE.Vector3(max.x, max.y, min.z))\n\n    geometry.vertices.push(new THREE.Vector3(max.x, min.y, max.z))\n    geometry.vertices.push(new THREE.Vector3(max.x, max.y, max.z))\n\n    geometry.vertices.push(new THREE.Vector3(min.x, min.y, max.z))\n    geometry.vertices.push(new THREE.Vector3(min.x, max.y, max.z))\n\n    const lines = new THREE.Line(geometry,\n      material, THREE.LinePieces)\n\n    viewer.impl.addOverlay(overlayId, lines)\n\n    viewer.impl.invalidate(\n      true, true, true)\n\n    return lines\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Set component material\n  //\n  /// //////////////////////////////////////////////////////\n  static async setMaterial (model, dbId, material) {\n    const fragIds = await Toolkit.getFragIds(\n      model, dbId)\n\n    const fragList = model.getFragmentList()\n\n    fragIds.forEach((fragId) => {\n      fragList.setMaterial(fragId, material)\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Recursively builds the model tree\n  //\n  /// //////////////////////////////////////////////////////\n  static buildModelTree (model, createNodeFunc = null) {\n    // builds model tree recursively\n    function _buildModelTreeRec (node) {\n      instanceTree.enumNodeChildren(node.dbId,\n        function (childId) {\n          var childNode = null\n\n          if (createNodeFunc) {\n            childNode = createNodeFunc(childId)\n          } else {\n            node.children = node.children || []\n\n            childNode = {\n              dbId: childId,\n              name: instanceTree.getNodeName(childId)\n            }\n\n            node.children.push(childNode)\n          }\n\n          _buildModelTreeRec(childNode)\n        })\n    }\n\n    // get model instance tree and root component\n    var instanceTree = model.getData().instanceTree\n\n    var rootId = instanceTree.getRootId()\n\n    var rootNode = {\n      dbId: rootId,\n      name: instanceTree.getNodeName(rootId)\n    }\n\n    _buildModelTreeRec(rootNode)\n\n    return rootNode\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Recursively execute task on model tree\n  //\n  /// //////////////////////////////////////////////////////\n  static executeTaskOnModelTree (model, task) {\n    const taskResults = []\n\n    function executeTaskOnModelTreeRec (dbId) {\n      instanceTree.enumNodeChildren(dbId,\n        function (childId) {\n          taskResults.push(task(model, childId))\n\n          executeTaskOnModelTreeRec(childId)\n        })\n    }\n\n    // get model instance tree and root component\n    const instanceTree = model.getData().instanceTree\n\n    const rootId = instanceTree.getRootId()\n\n    executeTaskOnModelTreeRec(rootId)\n\n    return taskResults\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  static hide (viewer, dbIds = [], model = null) {\n    try {\n      model = model || viewer.activeModel || viewer.model\n\n      viewer.hide(dbIds)\n\n      const targetIds = Array.isArray(dbIds) ? dbIds : [dbIds]\n\n      const tasks = targetIds.map((dbId) => {\n        return new Promise((resolve) => {\n          viewer.impl.visibilityManager.setNodeOff(\n            dbId, true)\n\n          resolve()\n        })\n      })\n\n      return Promise.all(tasks)\n    } catch (ex) {\n      return Promise.reject(ex)\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  static show (viewer, dbIds = [], model = null) {\n    try {\n      model = model || viewer.activeModel || viewer.model\n\n      viewer.show(dbIds)\n\n      const targetIds = Array.isArray(dbIds) ? dbIds : [dbIds]\n\n      targetIds.forEach((dbId) => {\n        viewer.impl.visibilityManager.setNodeOff(\n          dbId, false)\n      })\n\n      return Promise.resolve()\n    } catch (ex) {\n      return Promise.reject(ex)\n    }\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  static async isolateFull (viewer, dbIds = [], model = null) {\n    try {\n      model = model || viewer.activeModel || viewer.model\n\n      const vizMng = viewer.impl.visibilityManager\n\n      vizMng.isolate(dbIds, model)\n\n      const targetIds = Array.isArray(dbIds) ? dbIds : [dbIds]\n\n      const targetLeafIds = await Toolkit.getLeafNodes(\n        model, targetIds)\n\n      const leafIds = await Toolkit.getLeafNodes(model)\n\n      const leafTasks = leafIds.map((dbId) => {\n        return new Promise((resolveLeaf) => {\n          const show = !targetLeafIds.length ||\n            targetLeafIds.indexOf(dbId) > -1\n\n          viewer[show ? 'show' : 'hide'](dbId, model)\n          // vizMng.setNodeOff(dbId, !show, model)\n\n          resolveLeaf()\n        })\n      })\n\n      return Promise.all(leafTasks)\n    } catch (ex) {\n      return Promise.reject(ex)\n    }\n  }\n\n  /// ////////////////////////////////////////////////////////////////\n  // Rotate selected fragments\n  //\n  /// ////////////////////////////////////////////////////////////////\n  static rotateFragments (viewer, fragIds, axis, angle, center, model = null) {\n    var quaternion = new THREE.Quaternion()\n\n    quaternion.setFromAxisAngle(axis, angle)\n\n    model = model || viewer.activeModel || viewer.model\n\n    fragIds.forEach((fragId) => {\n      var fragProxy = viewer.impl.getFragmentProxy(\n        model, fragId)\n\n      fragProxy.getAnimTransform()\n\n      var position = new THREE.Vector3(\n        fragProxy.position.x - center.x,\n        fragProxy.position.y - center.y,\n        fragProxy.position.z - center.z)\n\n      position.applyQuaternion(quaternion)\n\n      position.add(center)\n\n      fragProxy.position = position\n\n      fragProxy.quaternion.multiplyQuaternions(\n        quaternion, fragProxy.quaternion)\n\n      fragProxy.updateAnimTransform()\n    })\n  }\n\n  /// //////////////////////////////////////////////////////\n  // A fix for viewer.restoreState\n  // that also restores pivotPoint\n  //\n  /// //////////////////////////////////////////////////////\n  static restoreStateWithPivot (\n    viewer, state, filter = null, immediate = false) {\n    const onStateRestored = () => {\n      viewer.removeEventListener(\n        Autodesk.Viewing.VIEWER_STATE_RESTORED_EVENT,\n        onStateRestored)\n\n      const pivot = state.viewport.pivotPoint\n\n      setTimeout(() => {\n        viewer.navigation.setPivotPoint(\n          new THREE.Vector3(\n            pivot[0], pivot[1], pivot[2]))\n      }, immediate ? 0 : 1250)\n    }\n\n    viewer.addEventListener(\n      Autodesk.Viewing.VIEWER_STATE_RESTORED_EVENT,\n      onStateRestored)\n\n    viewer.restoreState(state, filter, immediate)\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  static getComponentsByParentName (name, model) {\n    const instanceTree = model.getData().instanceTree\n\n    const rootId = instanceTree.getRootId()\n\n    let parentId = 0\n\n    instanceTree.enumNodeChildren(rootId,\n      (childId) => {\n        const nodeName = instanceTree.getNodeName(childId)\n\n        if (nodeName.indexOf(name) > -1) {\n          parentId = childId\n        }\n      })\n\n    return parentId > 0\n      ? Toolkit.getLeafNodes(model, parentId)\n      : []\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Creates a standard THREE.Mesh out of a Viewer\n  // component\n  //\n  /// //////////////////////////////////////////////////////\n  static buildComponentGeometry (\n    viewer, model, dbId, faceFilter) {\n    // first we assume the component dbId is a leaf\n    // component: ie has no child so contains\n    // geometry. This util method will return all fragIds\n    // associated with that specific dbId\n    const fragIds = Toolkit.getLeafFragIds(model, dbId)\n\n    let matrixWorld = null\n\n    const meshGeometry = new THREE.Geometry()\n\n    fragIds.forEach((fragId) => {\n      // for each fragId, get the proxy in order to access\n      // THREE geometry\n      const renderProxy =\n        viewer.impl.getRenderProxy(\n          model, fragId)\n\n      matrixWorld = matrixWorld || renderProxy.matrixWorld\n\n      const geometry = renderProxy.geometry\n\n      const attributes = geometry.attributes\n\n      const positions = geometry.vb\n        ? geometry.vb\n        : attributes.position.array\n\n      const indices = attributes.index.array || geometry.ib\n\n      const stride = geometry.vb ? geometry.vbstride : 3\n\n      const offsets = [{\n        count: indices.length,\n        index: 0,\n        start: 0\n      }]\n\n      for (var oi = 0, ol = offsets.length; oi < ol; ++oi) {\n        var start = offsets[oi].start\n        var count = offsets[oi].count\n        var index = offsets[oi].index\n\n        for (var i = start, il = start + count; i < il; i += 3) {\n          const a = index + indices[i]\n          const b = index + indices[i + 1]\n          const c = index + indices[i + 2]\n\n          const vA = new THREE.Vector3()\n          const vB = new THREE.Vector3()\n          const vC = new THREE.Vector3()\n\n          vA.fromArray(positions, a * stride)\n          vB.fromArray(positions, b * stride)\n          vC.fromArray(positions, c * stride)\n\n          if (!faceFilter || faceFilter(vA, vB, vC)) {\n            const faceIdx = meshGeometry.vertices.length\n\n            meshGeometry.vertices.push(vA)\n            meshGeometry.vertices.push(vB)\n            meshGeometry.vertices.push(vC)\n\n            const face = new THREE.Face3(\n              faceIdx, faceIdx + 1, faceIdx + 2)\n\n            meshGeometry.faces.push(face)\n          }\n        }\n      }\n    })\n\n    meshGeometry.applyMatrix(matrixWorld)\n\n    return meshGeometry\n  }\n\n  /// //////////////////////////////////////////////////////\n  // Creates a standard THREE.Mesh out of a Viewer\n  // component\n  //\n  /// //////////////////////////////////////////////////////\n  static buildComponentMesh (\n    viewer, model, dbId, faceFilter, material) {\n    const meshGeometry =\n      Toolkit.buildComponentGeometry(\n        viewer, model, dbId, faceFilter)\n\n    meshGeometry.computeFaceNormals()\n    meshGeometry.computeVertexNormals()\n\n    // creates THREE.Mesh\n    const mesh = new THREE.Mesh(\n      meshGeometry, material)\n\n    mesh.dbId = dbId\n\n    return mesh\n  }\n\n  /// //////////////////////////////////////////////////////\n  //\n  //\n  /// //////////////////////////////////////////////////////\n  static selectiveExplode (viewer, scale, excludedFragIds, model = null) {\n    model = model || viewer.activeModel || viewer.model\n\n    var svf = model.getData()\n\n    var mc = model.getVisibleBounds(true).center()\n\n    var fragList = model.getFragmentList()\n\n    var pt = new THREE.Vector3()\n\n    // Input scale is in the range 0-1, where 0\n    // means no displacement, and 1 maximum reasonable displacement.\n    scale *= 2\n\n    // If we have a full part hierarchy we can use a\n    // better grouping strategy when exploding\n    if (svf.instanceTree && svf.instanceTree.nodeAccess.nodeBoxes && scale !== 0) {\n      var scaledExplodeDepth = scale * (svf.instanceTree.maxDepth - 1) + 1\n      var explodeDepth = 0 | scaledExplodeDepth\n      var currentSegmentFraction = scaledExplodeDepth - explodeDepth\n\n      var it = svf.instanceTree\n      var tmpBox = new Float32Array(6);\n\n      (function explodeRec (nodeId, depth, cx, cy, cz, ox, oy, oz) {\n        var oscale = scale * 2\n\n        // smooth transition of this tree depth\n        // from non-exploded to exploded state\n        if (depth == explodeDepth) { oscale *= currentSegmentFraction }\n\n        it.getNodeBox(nodeId, tmpBox)\n\n        var mycx = 0.5 * (tmpBox[0] + tmpBox[3])\n        var mycy = 0.5 * (tmpBox[1] + tmpBox[4])\n        var mycz = 0.5 * (tmpBox[2] + tmpBox[5])\n\n        if (depth > 0 && depth <= explodeDepth) {\n          var dx = (mycx - cx) * oscale\n          var dy = (mycy - cy) * oscale\n          var dz = (mycz - cz) * oscale\n\n          // var omax = Math.max(dx, Math.max(dy, dz));\n          ox += dx\n          oy += dy\n          oz += dz\n        }\n\n        svf.instanceTree.enumNodeChildren(nodeId, function (dbId) {\n          explodeRec(dbId, depth + 1, mycx, mycy, mycz, ox, oy, oz)\n        }, false)\n\n        svf.instanceTree.enumNodeFragments(nodeId, function (fragId) {\n          if (excludedFragIds.indexOf(fragId.toString()) < 0) {\n            pt.x = ox\n            pt.y = oy\n            pt.z = oz\n\n            fragList.updateAnimTransform(fragId, null, null, pt)\n          }\n        }, false)\n      })(svf.instanceTree.getRootId(), 0, mc.x, mc.y, mc.x, 0, 0, 0)\n    } else {\n      var boxes = fragList.fragments.boxes\n\n      var nbFrags = fragList.getCount()\n\n      for (var fragId = 0; fragId < nbFrags; ++fragId) {\n        if (excludedFragIds.indexOf(fragId.toString()) < 0) {\n          if (scale == 0) {\n            fragList.updateAnimTransform(fragId)\n          } else {\n            var box_offset = fragId * 6\n\n            var cx = 0.5 * (boxes[box_offset] + boxes[box_offset + 3])\n            var cy = 0.5 * (boxes[box_offset + 1] + boxes[box_offset + 4])\n            var cz = 0.5 * (boxes[box_offset + 2] + boxes[box_offset + 5])\n\n            cx = scale * (cx - mc.x)\n            cy = scale * (cy - mc.y)\n            cz = scale * (cz - mc.z)\n\n            pt.x = cx\n            pt.y = cy\n            pt.z = cz\n\n            fragList.updateAnimTransform(fragId, null, null, pt)\n          }\n        }\n      }\n    }\n  }\n}\n"],"sourceRoot":""}